import { test as base, expect, chromium as pwChromium } from '@playwright/test';
import fs from 'fs';
import path from 'path';

// If you want SQLite support, install better-sqlite3:
//    npm i -D better-sqlite3
// Then uncomment the next line.
// @ts-ignore
// import Database from 'better-sqlite3';

/*
TODO
make the scan date and finished time stamp dynamic.
Comment out code. 
Make documentation. 
Turn this into a framework that can be generalized to other queries. (function out code)
Instead of writing to the console have it write to a job and error log.
*/

// ------------------ Config ------------------
const OUTPUT_MODE: 'csv' | 'sqlite' = 'csv'; // <--- change to 'sqlite' to write to a SQLite DB
const CSV_PATH = path.resolve(process.cwd(), 'path');
const SQLITE_PATH = path.resolve(process.cwd(), 'vulnerabilities.db');
// --------------------------------------------

// Override default browser fixture to launch custom Chrome
const test = base.extend({
  browser: async ({}, use) => {
    const browser = await pwChromium.launch({
      headless: false,
      executablePath: 'C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe'
    });
    await use(browser);
    await browser.close();
  }
});

// ---------- utils: data shaping ----------
function toArrayFromGraphQL(data: any): any[] {
  if (!data) return [];
  if (Array.isArray(data)) return data;

  // Common shapes
  if (Array.isArray(data.hits)) return data.hits;
  if (Array.isArray(data.items)) return data.items;
  if (Array.isArray(data.edges)) return data.edges.map((e: any) => e.node ?? e);

  // Fallback: single object -> wrap
  if (typeof data === 'object') return [data];

  return [];
}

// Flatten nested objects to dotted keys for CSV
function flatten(obj: any, prefix = '', out: Record<string, any> = {}) {
  if (obj && typeof obj === 'object' && !Array.isArray(obj)) {
    for (const [k, v] of Object.entries(obj)) {
      const key = prefix ? `${prefix}.${k}` : k;
      flatten(v, key, out);
    }
  } else if (Array.isArray(obj)) {
    // store arrays as JSON strings
    out[prefix] = JSON.stringify(obj);
  } else {
    out[prefix] = obj;
  }
  return out;
}

// Build CSV content from records of unknown shape
function buildCsv(records: any[]): string {
  const flat = records.map(r => flatten(r));
  const headers = Array.from(
    new Set(flat.flatMap(obj => Object.keys(obj)))
  );

  const escape = (val: any) => {
    if (val === null || val === undefined) return '';
    const str = String(val);
    // quote if contains comma, quote, or newline
    if (/[",\n]/.test(str)) {
      return `"${str.replace(/"/g, '""')}"`;
    }
    return str;
  };

  const lines: string[] = [];
  lines.push(headers.join(','));
  for (const row of flat) {
    const line = headers.map(h => escape(row[h])).join(',');
    lines.push(line);
  }
  return lines.join('\n');
}

// ---------- utils: outputs ----------
function writeCsv(records: any[], filePath: string) {
  if (!records.length) {
    console.log('No records to write to CSV.');
    return;
  }
  const csv = buildCsv(records);
  fs.writeFileSync(filePath, csv, 'utf8');
  console.log(`✅ CSV written: ${filePath} (${records.length} rows)`);
}

// If using SQLite JSON storage
function writeSqliteJson(records: any[], dbPath: string) {
  if (!records.length) {
    console.log('No records to write to SQLite.');
    return;
  }

  // Lazy import to avoid requiring the package if not used
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  const Database = require('better-sqlite3');
  const db = new Database(dbPath);

  db.exec(`
    CREATE TABLE IF NOT EXISTS vulnerabilities (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      record_json TEXT NOT NULL,
      inserted_at TEXT NOT NULL
    )
  `);

  const now = new Date().toISOString();
  const stmt = db.prepare(`INSERT INTO vulnerabilities (record_json, inserted_at) VALUES (?, ?)`);
  const tx = db.transaction((rows: any[]) => {
    for (const r of rows) {
      stmt.run(JSON.stringify(r), now);
    }
  });
  tx(records);
  db.close();
  console.log(`✅ SQLite written: ${dbPath} (+${records.length} rows)`);
}

// ---- Test ----
test('GraphQL request after login and export results', async ({ browser }) => {
  test.setTimeout(120_000);

  const context = await browser.newContext();
  const page = await context.newPage();

  // 1) Go to site and wait for login/app readiness
  await page.goto('siteplaceholder', { waitUntil: 'domcontentloaded' });
  await page.waitForLoadState('networkidle');

  // 2) Extract cookie / token
  const cookies = await context.cookies();
  const authCookie = cookies.find(c => c.name === 'cookieplaceholder'); // <-- adjust if needed
  const bearerFromCookie = authCookie?.value;

  const bearerFromLocalStorage = await page.evaluate(() => {
    const candidates = ['access_token', 'id_token', 'authToken', 'token', 'cookieplaceholder'];
    for (const k of candidates) {
      const v = localStorage.getItem(k);
      if (v && typeof v === 'string' && v.length > 10) return v;
    }
    return null;
  });

  const bearer = bearerFromCookie ?? bearerFromLocalStorage ?? null;
  if (!bearer) throw new Error('Auth token not found in cookies or localStorage.');

  // 3) Prepare & execute GraphQL query (same-origin fetch in page context so cookies ride along)
  const endpoint = 'sitequerylinkplaceholder'; // confirm in DevTools

  const queryPayload = {
    operationName: 'opnameplaceholder',
    variables: {
      aideId: 'aide placeholder',
      scanDate: '2025-10-11'//needs to be dynamic,
      status: 'OPEN',
      finishedTimestamp: 1760463756441//probably also needs to be dynamic,
/*
replace with 
scanDate: new Date().toISOString().split('T')[0], // e.g. '2025-11-06'
status: 'OPEN',
finishedTimestamp: Date.now(), // Unix timestamp in ms

*/
      fetchVulnRecordsSQL: false,
      options: {
        sort: ['SeverityOrder:asc'],
        searchValue: '',
        page: 1,
        filter: ['AIDEID = "aideplaceholder"', ''],
        facets: [
          'placeholder1',
          'placeholder2',
          'placeholder3',
          'placeholder4',
          'placeholder5',
          'placeholder6',
          'placeholder7',
          'placeholder8',
          'placeholder9',
          'placeholder10',
          'placeholder11'
        ],
        attributesToRetrieve: ['*'],
        matchingStrategy: '',
        attributesToSearchOn: ['*']
      }
    },
    query: `
      query getOnPremVulnerabilities(
        $aideId: String!,
        $status: VulnStatus!,
        $scanDate: String!,
        $options: VulnOptions,
        $finishedTimestamp: Float,
        $fetchVulnRecordsSQL: Boolean,
        $isTenableManaged: Boolean
      ) {
        getOnPremVulnerabilities(
          aideId: $aideId
          status: $status
          scanDate: $scanDate
          options: $options
          finishedTimestamp: $finishedTimestamp
          fetchVulnRecordsSQL: $fetchVulnRecordsSQL
          isTenableManaged: $isTenableManaged
        )
      }
    `
  };

  const graphqlResponse = await page.evaluate(
    async ({ endpoint, payload, token }) => {
      const res = await fetch(endpoint, {
        method: 'POST',
        headers: {
          'content-type': 'application/json',
          'authorization': `Bearer ${token}`
        },
        credentials: 'include',
        body: JSON.stringify(payload)
      });
      const text = await res.text();
      try {
        return JSON.parse(text);
      } catch {
        return { parseError: true, text, status: res.status };
      }
    },
    { endpoint, payload: queryPayload, token: bearer }
  );

  console.log('GraphQL Raw Response:', JSON.stringify(graphqlResponse, null, 2));

  // 4) Validate and extract records
  const data = graphqlResponse?.data?.getOnPremVulnerabilities;
  expect(data).toBeDefined();

  const records = toArrayFromGraphQL(data);
  console.log(`Found ${records.length} record(s).`);

  // 5) Export
  if (OUTPUT_MODE === 'csv') {
    writeCsv(records, CSV_PATH);
  } else if (OUTPUT_MODE === 'sqlite') {
    writeSqliteJson(records, SQLITE_PATH);
  }

  // Optional: Assertions on export presence
  if (OUTPUT_MODE === 'csv') {
    expect(fs.existsSync(CSV_PATH)).toBeTruthy();
  } else {
    expect(fs.existsSync(SQLITE_PATH)).toBeTruthy();
  }

  await context.close();
});
-------------------------------
gpt sql
import sql from 'mssql';

// ---------- utils: SQL Server output (Windows Auth, structured) ----------
async function writeSqlServer(records: any[], config: any) {
  if (!records.length) {
    console.log('No records to write to SQL Server.');
    return;
  }

  const pool = await sql.connect(config);
  const flatRecords = records.map(r => flatten(r)); // reuse your flatten() function
  const columns = Object.keys(flatRecords[0]);
  const placeholders = columns.map(c => `@${c}`).join(', ');
  const insertQuery = `
    INSERT INTO dbo.vulnerabilities (${columns.join(', ')})
    VALUES (${placeholders});
  `;

  try {
    const transaction = new sql.Transaction(pool);
    await transaction.begin();

    for (const record of flatRecords) {
      const request = new sql.Request(transaction);
      for (const col of columns) {
        const val = record[col];
        if (typeof val === 'number') {
          request.input(col, sql.Float, val);
        } else if (
          typeof val === 'string' &&
          /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}/.test(val)
        ) {
          request.input(col, sql.DateTime2, val);
        } else {
          request.input(col, sql.NVarChar(sql.MAX), val ?? null);
        }
      }
      await request.query(insertQuery);
    }

    await transaction.commit();
    console.log(`✅ SQL Server written (${flatRecords.length} rows)`);
  } catch (err) {
    console.error('❌ SQL Server write failed:', err);
  } finally {
    await pool.close();
  }
}
-------------------------------------------
calling it

const sqlConfig = {
  server: 'localhost\\SQLEXPRESS', // or your host\instance
  database: 'YourDatabaseName',
  options: {
    encrypt: false,
    trustServerCertificate: true
  },
  authentication: {
    type: 'ntlm',
    options: {
      domain: 'YOURDOMAIN',     // or leave blank for local user auth
      userName: '',             // empty = current user context
      password: ''              // empty = current user context
    }
  }
};
------------------------------------------------------
CREATE TABLE dbo.vulnerabilities (
    id INT IDENTITY(1,1) PRIMARY KEY,
    scan_date DATE NULL,
    hostname NVARCHAR(255) NULL,
    ip_address NVARCHAR(100) NULL,
    severity NVARCHAR(50) NULL,
    vuln_id NVARCHAR(100) NULL,
    vuln_name NVARCHAR(500) NULL,
    description NVARCHAR(MAX) NULL,
    solution NVARCHAR(MAX) NULL,
    inserted_at DATETIME2 DEFAULT SYSUTCDATETIME()
);
-----------------------------------------------
Sha256IdAppCombo	AssociatedApps	ResourceName	Sha256Id	VIT	VulnAliases	VulnSummary	AIDEID	Source	ToolName	Src	Details	Summary	Href	InstanceId	UniqueID	ResolutionStatus	ResolutionStatusMarkedByMsId	ResolutionStatusMarkedByName	ResolutionStatusMarkedDate	SpecificRemediation	IsActive	AffectedPaths	AssignmentGroup	ITSMTeam	TimingDiscovered	TimingDiscoveredEpoch	ToolInitialDetectionDate	TimingResolved	TimingScanned	TimingAuthenticatedScanned	VulnDetails	VulnCategory	VulnGenericRemediation	VulnSeverity	SeverityOrder	RelatedCVEs	Environment	IsManaged	MarkedManagedOverrideByName	MarkedManagedOverrideByMsId	CVSS3Score	OrgName	OrgId	OSDetails	InsertionTimestamp	FirstInsertionTimestamp	SLACountdown	Questions	HasQuestions	Type	CommonID	LineOfBusiness	BusinessSegment	ApplicationName	IsBlocked	BlockedDate	InternalSlaDateEpoch	ExternalSlaDateEpoch	SlaDateEpoch	IsDeleted	ContestedReason	ContestedDescription	ContestedStepsTaken	ManagedBuckets	ManagedAIDEID	EndOfLife	DeviceType	ComputerName	HostName	DomainName	AssetType	BusinessServices	AssetTags	VulnName	AssetSha256Id	AssetCategory	AssetName	WebhookStatus	WebhookAssignedToMsId	WebhookAssignedToName	VulnerabilityIdentifier	VulnSha256Id	KnownExploited	HasActiveRiskRecord	IsUnsupportedOS	IsUnpatched	RiskRecords	OwningAskIdOverride	OwningAskIdOverrideByMsId	OwningAskIdOverrideByName	OwningAskIdOverrideCount	OwningAskIdOverrideDate	ModifiedBy	ManagedLastUpdated	OGAIDEID	TransferHistory	isRefreshed	processAs

-------------------------------------------------------
CREATE TABLE dbo.vulnerabilities (
    Id INT IDENTITY(1,1) PRIMARY KEY,

    Sha256IdAppCombo NVARCHAR(200) NULL,
    AssociatedApps NVARCHAR(MAX) NULL,
    ResourceName NVARCHAR(500) NULL,
    Sha256Id NVARCHAR(200) NULL,
    VIT NVARCHAR(100) NULL,
    VulnAliases NVARCHAR(500) NULL,
    VulnSummary NVARCHAR(MAX) NULL,
    AIDEID NVARCHAR(100) NULL,
    Source NVARCHAR(100) NULL,
    ToolName NVARCHAR(100) NULL,
    Src NVARCHAR(100) NULL,
    Details NVARCHAR(MAX) NULL,
    Summary NVARCHAR(MAX) NULL,
    Href NVARCHAR(1000) NULL,
    InstanceId NVARCHAR(200) NULL,
    UniqueID NVARCHAR(200) NULL,
    ResolutionStatus NVARCHAR(100) NULL,
    ResolutionStatusMarkedByMsId NVARCHAR(200) NULL,
    ResolutionStatusMarkedByName NVARCHAR(200) NULL,
    ResolutionStatusMarkedDate DATETIME2 NULL,
    SpecificRemediation NVARCHAR(MAX) NULL,
    IsActive BIT NULL,
    AffectedPaths NVARCHAR(MAX) NULL,
    AssignmentGroup NVARCHAR(200) NULL,
    ITSMTeam NVARCHAR(200) NULL,
    TimingDiscovered DATETIME2 NULL,
    TimingDiscoveredEpoch BIGINT NULL,
    ToolInitialDetectionDate DATETIME2 NULL,
    TimingResolved DATETIME2 NULL,
    TimingScanned DATETIME2 NULL,
    TimingAuthenticatedScanned DATETIME2 NULL,
    VulnDetails NVARCHAR(MAX) NULL,
    VulnCategory NVARCHAR(200) NULL,
    VulnGenericRemediation NVARCHAR(MAX) NULL,
    VulnSeverity NVARCHAR(50) NULL,
    SeverityOrder INT NULL,
    RelatedCVEs NVARCHAR(MAX) NULL,
    Environment NVARCHAR(100) NULL,
    IsManaged BIT NULL,
    MarkedManagedOverrideByName NVARCHAR(200) NULL,
    MarkedManagedOverrideByMsId NVARCHAR(200) NULL,
    CVSS3Score FLOAT NULL,
    OrgName NVARCHAR(200) NULL,
    OrgId NVARCHAR(100) NULL,
    OSDetails NVARCHAR(500) NULL,
    InsertionTimestamp DATETIME2 NULL,
    FirstInsertionTimestamp DATETIME2 NULL,
    SLACountdown INT NULL,
    Questions NVARCHAR(MAX) NULL,
    HasQuestions BIT NULL,
    Type NVARCHAR(100) NULL,
    CommonID NVARCHAR(100) NULL,
    LineOfBusiness NVARCHAR(200) NULL,
    BusinessSegment NVARCHAR(200) NULL,
    ApplicationName NVARCHAR(500) NULL,
    IsBlocked BIT NULL,
    BlockedDate DATETIME2 NULL,
    InternalSlaDateEpoch BIGINT NULL,
    ExternalSlaDateEpoch BIGINT NULL,
    SlaDateEpoch BIGINT NULL,
    IsDeleted BIT NULL,
    ContestedReason NVARCHAR(500) NULL,
    ContestedDescription NVARCHAR(MAX) NULL,
    ContestedStepsTaken NVARCHAR(MAX) NULL,
    ManagedBuckets NVARCHAR(MAX) NULL,
    ManagedAIDEID NVARCHAR(200) NULL,
    EndOfLife NVARCHAR(100) NULL,
    DeviceType NVARCHAR(200) NULL,
    ComputerName NVARCHAR(200) NULL,
    HostName NVARCHAR(200) NULL,
    DomainName NVARCHAR(200) NULL,
    AssetType NVARCHAR(100) NULL,
    BusinessServices NVARCHAR(MAX) NULL,
    AssetTags NVARCHAR(MAX) NULL,
    VulnName NVARCHAR(500) NULL,
    AssetSha256Id NVARCHAR(200) NULL,
    AssetCategory NVARCHAR(200) NULL,
    AssetName NVARCHAR(500) NULL,
    WebhookStatus NVARCHAR(100) NULL,
    WebhookAssignedToMsId NVARCHAR(200) NULL,
    WebhookAssignedToName NVARCHAR(200) NULL,
    VulnerabilityIdentifier NVARCHAR(200) NULL,
    VulnSha256Id NVARCHAR(200) NULL,
    KnownExploited BIT NULL,
    HasActiveRiskRecord BIT NULL,
    IsUnsupportedOS BIT NULL,
    IsUnpatched BIT NULL,
    RiskRecords NVARCHAR(MAX) NULL,
    OwningAskIdOverride NVARCHAR(200) NULL,
    OwningAskIdOverrideByMsId NVARCHAR(200) NULL,
    OwningAskIdOverrideByName NVARCHAR(200) NULL,
    OwningAskIdOverrideCount INT NULL,
    OwningAskIdOverrideDate DATETIME2 NULL,
    ModifiedBy NVARCHAR(200) NULL,
    ManagedLastUpdated DATETIME2 NULL,
    OGAIDEID NVARCHAR(200) NULL,
    TransferHistory NVARCHAR(MAX) NULL,
    IsRefreshed BIT NULL,
    ProcessAs NVARCHAR(100) NULL,

    inserted_at DATETIME2 DEFAULT SYSUTCDATETIME()
);
---------------------------------------
import sql from 'mssql';

// ---------- SQL Server insert (structured columns, Windows Auth) ----------
async function writeSqlServer(records: any[], config: any) {
  if (!records.length) {
    console.log('No records to write to SQL Server.');
    return;
  }

  const pool = await sql.connect(config);

  // Columns from your CSV in correct order
  const columns = [
    'Sha256IdAppCombo','AssociatedApps','ResourceName','Sha256Id','VIT','VulnAliases',
    'VulnSummary','AIDEID','Source','ToolName','Src','Details','Summary','Href',
    'InstanceId','UniqueID','ResolutionStatus','ResolutionStatusMarkedByMsId',
    'ResolutionStatusMarkedByName','ResolutionStatusMarkedDate','SpecificRemediation',
    'IsActive','AffectedPaths','AssignmentGroup','ITSMTeam','TimingDiscovered',
    'TimingDiscoveredEpoch','ToolInitialDetectionDate','TimingResolved','TimingScanned',
    'TimingAuthenticatedScanned','VulnDetails','VulnCategory','VulnGenericRemediation',
    'VulnSeverity','SeverityOrder','RelatedCVEs','Environment','IsManaged',
    'MarkedManagedOverrideByName','MarkedManagedOverrideByMsId','CVSS3Score','OrgName',
    'OrgId','OSDetails','InsertionTimestamp','FirstInsertionTimestamp','SLACountdown',
    'Questions','HasQuestions','Type','CommonID','LineOfBusiness','BusinessSegment',
    'ApplicationName','IsBlocked','BlockedDate','InternalSlaDateEpoch',
    'ExternalSlaDateEpoch','SlaDateEpoch','IsDeleted','ContestedReason',
    'ContestedDescription','ContestedStepsTaken','ManagedBuckets','ManagedAIDEID',
    'EndOfLife','DeviceType','ComputerName','HostName','DomainName','AssetType',
    'BusinessServices','AssetTags','VulnName','AssetSha256Id','AssetCategory',
    'AssetName','WebhookStatus','WebhookAssignedToMsId','WebhookAssignedToName',
    'VulnerabilityIdentifier','VulnSha256Id','KnownExploited','HasActiveRiskRecord',
    'IsUnsupportedOS','IsUnpatched','RiskRecords','OwningAskIdOverride',
    'OwningAskIdOverrideByMsId','OwningAskIdOverrideByName','OwningAskIdOverrideCount',
    'OwningAskIdOverrideDate','ModifiedBy','ManagedLastUpdated','OGAIDEID',
    'TransferHistory','IsRefreshed','ProcessAs'
  ];

  const colList = columns.join(', ');
  const paramList = columns.map(c => `@${c}`).join(', ');
  const insertQuery = `
    INSERT INTO dbo.vulnerabilities (${colList})
    VALUES (${paramList});
  `;

  try {
    const transaction = new sql.Transaction(pool);
    await transaction.begin();

    for (const record of records) {
      const req = new sql.Request(transaction);
      for (const col of columns) {
        // Map directly to NVARCHAR(MAX) for simplicity; SQL will handle conversions
        req.input(col, sql.NVarChar(sql.MAX), record[col] ?? null);
      }
      await req.query(insertQuery);
    }

    await transaction.commit();
    console.log(`✅ SQL Server inserted ${records.length} rows`);
  } catch (err) {
    console.error('❌ SQL insert failed:', err);
  } finally {
    await pool.close();
  }
}
-------------------------------------------------
const sqlConfig = {
  server: 'localhost\\SQLEXPRESS',
  database: 'YourDatabaseName',
  options: {
    encrypt: false,
    trustServerCertificate: true
  },
  authentication: {
    type: 'ntlm',
    options: {
      domain: '',      // leave blank if local account
      userName: '',    // current user
      password: ''     // current user
    }
  }
};
-------------------------------------------------
await writeSqlServer(records, sqlConfig);
