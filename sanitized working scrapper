import { test as base, expect, chromium as pwChromium } from '@playwright/test';
import fs from 'fs';
import path from 'path';

// If you want SQLite support, install better-sqlite3:
//    npm i -D better-sqlite3
// Then uncomment the next line.
// @ts-ignore
// import Database from 'better-sqlite3';

/*
TODO
make the scan date and finished time stamp dynamic.
Comment out code. 
Make documentation. 
Turn this into a framework that can be generalized to other queries. (function out code)
Instead of writing to the console have it write to a job and error log.
*/

// ------------------ Config ------------------
const OUTPUT_MODE: 'csv' | 'sqlite' = 'csv'; // <--- change to 'sqlite' to write to a SQLite DB
const CSV_PATH = path.resolve(process.cwd(), 'path');
const SQLITE_PATH = path.resolve(process.cwd(), 'vulnerabilities.db');
// --------------------------------------------

// Override default browser fixture to launch custom Chrome
const test = base.extend({
  browser: async ({}, use) => {
    const browser = await pwChromium.launch({
      headless: false,
      executablePath: 'C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe'
    });
    await use(browser);
    await browser.close();
  }
});

// ---------- utils: data shaping ----------
function toArrayFromGraphQL(data: any): any[] {
  if (!data) return [];
  if (Array.isArray(data)) return data;

  // Common shapes
  if (Array.isArray(data.hits)) return data.hits;
  if (Array.isArray(data.items)) return data.items;
  if (Array.isArray(data.edges)) return data.edges.map((e: any) => e.node ?? e);

  // Fallback: single object -> wrap
  if (typeof data === 'object') return [data];

  return [];
}

// Flatten nested objects to dotted keys for CSV
function flatten(obj: any, prefix = '', out: Record<string, any> = {}) {
  if (obj && typeof obj === 'object' && !Array.isArray(obj)) {
    for (const [k, v] of Object.entries(obj)) {
      const key = prefix ? `${prefix}.${k}` : k;
      flatten(v, key, out);
    }
  } else if (Array.isArray(obj)) {
    // store arrays as JSON strings
    out[prefix] = JSON.stringify(obj);
  } else {
    out[prefix] = obj;
  }
  return out;
}

// Build CSV content from records of unknown shape
function buildCsv(records: any[]): string {
  const flat = records.map(r => flatten(r));
  const headers = Array.from(
    new Set(flat.flatMap(obj => Object.keys(obj)))
  );

  const escape = (val: any) => {
    if (val === null || val === undefined) return '';
    const str = String(val);
    // quote if contains comma, quote, or newline
    if (/[",\n]/.test(str)) {
      return `"${str.replace(/"/g, '""')}"`;
    }
    return str;
  };

  const lines: string[] = [];
  lines.push(headers.join(','));
  for (const row of flat) {
    const line = headers.map(h => escape(row[h])).join(',');
    lines.push(line);
  }
  return lines.join('\n');
}

// ---------- utils: outputs ----------
function writeCsv(records: any[], filePath: string) {
  if (!records.length) {
    console.log('No records to write to CSV.');
    return;
  }
  const csv = buildCsv(records);
  fs.writeFileSync(filePath, csv, 'utf8');
  console.log(`✅ CSV written: ${filePath} (${records.length} rows)`);
}

// If using SQLite JSON storage
function writeSqliteJson(records: any[], dbPath: string) {
  if (!records.length) {
    console.log('No records to write to SQLite.');
    return;
  }

  // Lazy import to avoid requiring the package if not used
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  const Database = require('better-sqlite3');
  const db = new Database(dbPath);

  db.exec(`
    CREATE TABLE IF NOT EXISTS vulnerabilities (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      record_json TEXT NOT NULL,
      inserted_at TEXT NOT NULL
    )
  `);

  const now = new Date().toISOString();
  const stmt = db.prepare(`INSERT INTO vulnerabilities (record_json, inserted_at) VALUES (?, ?)`);
  const tx = db.transaction((rows: any[]) => {
    for (const r of rows) {
      stmt.run(JSON.stringify(r), now);
    }
  });
  tx(records);
  db.close();
  console.log(`✅ SQLite written: ${dbPath} (+${records.length} rows)`);
}

// ---- Test ----
test('GraphQL request after login and export results', async ({ browser }) => {
  test.setTimeout(120_000);

  const context = await browser.newContext();
  const page = await context.newPage();

  // 1) Go to site and wait for login/app readiness
  await page.goto('siteplaceholder', { waitUntil: 'domcontentloaded' });
  await page.waitForLoadState('networkidle');

  // 2) Extract cookie / token
  const cookies = await context.cookies();
  const authCookie = cookies.find(c => c.name === 'cookieplaceholder'); // <-- adjust if needed
  const bearerFromCookie = authCookie?.value;

  const bearerFromLocalStorage = await page.evaluate(() => {
    const candidates = ['access_token', 'id_token', 'authToken', 'token', 'cookieplaceholder'];
    for (const k of candidates) {
      const v = localStorage.getItem(k);
      if (v && typeof v === 'string' && v.length > 10) return v;
    }
    return null;
  });

  const bearer = bearerFromCookie ?? bearerFromLocalStorage ?? null;
  if (!bearer) throw new Error('Auth token not found in cookies or localStorage.');

  // 3) Prepare & execute GraphQL query (same-origin fetch in page context so cookies ride along)
  const endpoint = 'sitequerylinkplaceholder'; // confirm in DevTools

  const queryPayload = {
    operationName: 'opnameplaceholder',
    variables: {
      aideId: 'aide placeholder',
      scanDate: '2025-10-11'//needs to be dynamic,
      status: 'OPEN',
      finishedTimestamp: 1760463756441//probably also needs to be dynamic,
      fetchVulnRecordsSQL: false,
      options: {
        sort: ['SeverityOrder:asc'],
        searchValue: '',
        page: 1,
        filter: ['AIDEID = "aideplaceholder"', ''],
        facets: [
          'placeholder1',
          'placeholder2',
          'placeholder3',
          'placeholder4',
          'placeholder5',
          'placeholder6',
          'placeholder7',
          'placeholder8',
          'placeholder9',
          'placeholder10',
          'placeholder11'
        ],
        attributesToRetrieve: ['*'],
        matchingStrategy: '',
        attributesToSearchOn: ['*']
      }
    },
    query: `
      query getOnPremVulnerabilities(
        $aideId: String!,
        $status: VulnStatus!,
        $scanDate: String!,
        $options: VulnOptions,
        $finishedTimestamp: Float,
        $fetchVulnRecordsSQL: Boolean,
        $isTenableManaged: Boolean
      ) {
        getOnPremVulnerabilities(
          aideId: $aideId
          status: $status
          scanDate: $scanDate
          options: $options
          finishedTimestamp: $finishedTimestamp
          fetchVulnRecordsSQL: $fetchVulnRecordsSQL
          isTenableManaged: $isTenableManaged
        )
      }
    `
  };

  const graphqlResponse = await page.evaluate(
    async ({ endpoint, payload, token }) => {
      const res = await fetch(endpoint, {
        method: 'POST',
        headers: {
          'content-type': 'application/json',
          'authorization': `Bearer ${token}`
        },
        credentials: 'include',
        body: JSON.stringify(payload)
      });
      const text = await res.text();
      try {
        return JSON.parse(text);
      } catch {
        return { parseError: true, text, status: res.status };
      }
    },
    { endpoint, payload: queryPayload, token: bearer }
  );

  console.log('GraphQL Raw Response:', JSON.stringify(graphqlResponse, null, 2));

  // 4) Validate and extract records
  const data = graphqlResponse?.data?.getOnPremVulnerabilities;
  expect(data).toBeDefined();

  const records = toArrayFromGraphQL(data);
  console.log(`Found ${records.length} record(s).`);

  // 5) Export
  if (OUTPUT_MODE === 'csv') {
    writeCsv(records, CSV_PATH);
  } else if (OUTPUT_MODE === 'sqlite') {
    writeSqliteJson(records, SQLITE_PATH);
  }

  // Optional: Assertions on export presence
  if (OUTPUT_MODE === 'csv') {
    expect(fs.existsSync(CSV_PATH)).toBeTruthy();
  } else {
    expect(fs.existsSync(SQLITE_PATH)).toBeTruthy();
  }

  await context.close();
});
